---
layout : post
title : "How to Design a Database"
author : "DAEUN"
---

## 데이터베이스 설계 6단계

1. 현실세계의 데이터를 식별한다.
2. 식별된 데이터를 유의미하면서 가장 작은 단위로 분리한다.
3. 테이블을 만들고 필드 값을 넣는다.
4. 기본키와 외래키를 정의한다.
5. 데이터베이스를 정규화한다.
6. 인덱스를 정의한다.


## 1. 현실세계의 데이터를 식별한다

* 시스템 분석
* 시스템 사용자 인터뷰
* 시스템에 관한 문서 참고


## 2. 식별된 데이터를 유의미하면서 가장 작은 단위로 분리한다.

여러 정보가 합쳐진 형태로 애트리뷰트에 저장되어 있다면 향후 정보를 분리하는 처리를 해야할 수 있다. 예를 들어, 사용자의 주소를 하나의 애트리뷰트로 저장하면 도, 시, 구, 동 등의 정보를 개별적으로 가져오기 위해 별도의 처리를 거쳐야하므로 비효율적이다. 따라서 당장 필요 없을지라도 미래에 데이터베이스를 고칠 일이 없도록 최소의 유의미한 데이터만을 하나의 애트리뷰트에 저장한다.


## 3. 테이블을 만들고 필드 값을 넣는다.

유의미한 테이블을 만들고 적절한 애트리뷰트를 정의한다.


## 4. 기본키와 외래키를 정의한다.

* **Primary Key** : 기본키. 각 행을 식별하는 키
* **Foreign Key** : 외래키. 참조하는 테이블의 기본키를 가리킨다.
* Candidate Key : 후보키. 유일성과 최소성을 만족하는 애트리뷰트 집합
* Super Key : 슈퍼키. 유일성은 만족하지만 최소성은 만족하지 않는 애트리뷰트 집합
* Alternate Key : 대체키. 후보키 중에서 기본키를 제외한 나머지 키
* Composite Key : 복합키. 2개 이상의 애트리뷰트를 합쳐 유일성을 만족하는 키. 기본키를 대신하기도 함

* 유일성(uniqueness) : 각 튜플(레코드)에 대해 모든 애트리뷰트의 값이 유일하게 구분되는 속성
* 최소성(minimality) : 최소한의 애트리뷰트로 튜플을 구성하는 속성


### 관계의 유형

* **1:1(One to One)** : 부모 테이블의 튜플 하나가 자식 테이블의 튜플 하나와 관계가 있다.

![one-to-one](/assets/images/one-to-one-relationship.PNG)


* **1:n(One to Many)** : 부모 테이블의 튜블 하나가 자식 테이블의 하나 이상의 튜플과 관계가 있다.

![one-to-many](/assets/images/one-to-many-relationship.PNG)


* **n:m(Many to Many)** : 부모 테이블의 여러 튜플과 자식 테이블의 여러 튜플 간 관계가 있다. 이 때에는 두 테이블을 one-to-many 관계로 연결해줄 Associate 테이블을 만들어 각 테이블의 기본키와 연결해준다. (Associate 테이블은 기본키가 없는 경우가 많다)

![many-to-many](/assets/images/many-to-many-relationship.PNG)


### 테이블 간 관계 설정 시 유의할 점

**참조 무결성(Referential Integrity)** : 외래키로 참조하는 자료가 반드시 존재해야하는 규칙. 부모 테이블에 외래키에 해당하는 기본키가 없다면 기아가 됨(orphan).

예를 들어, 부모 테이블의 튜플을 삭제하거나 수정할 경우, 해당 튜플의 기본키를 외래키로 갖고 있는 자식 테이블이 존재한다면 참조 무결성에 반하게 된다. 반대로 자식 테이블에 외래키를 갖는 레코드를 추가하거나 수정할 때, 부모 테이블에 외래키에 해당하는 기본키가 존재하지 않으면 참조 무결성이 성립되지 않는다.

참조 무결성을 위배하면 삭제 이상(Deletion Anomaly), 삽입 이상(Insertion Anomaly), 갱신 이상(Update Anomaly)이 발생한다.

참조 무결성을 지키기 위한 방법은 다음과 같다.

* 선언적 데이터 무결성(DRI, Declarative Referential Integrity) : 외래키 제약사항(foreing key constraints)을 정의함으로써 참조 무결성을 위배하지 않는다. 예를 들어, 부모 테이블의 레코드를 삭제하려할 때, 자식 테이블에 해당 튜플을 참조하는 레코드가 존재하면 함께 삭제하거나 삭제하지 않고 에러메시지를 보여주는 결과를 보여주도록 정의할 수 있다.

* 트리거(Triggers) : 트리거는 테이블을 생성할 때 정의되고 자동으로 실행된다. 참조 무결성에 위배되는 실행을 하려할 때 에러 메시지를 보여주도록 정의할 수 있다.


## 5. 데이터베이스를 정규화한다.

정규화를 통해
* 중복 데이터, 필드를 최소화할 수 있다.
* 삭제, 삽입, 갱신 이상 현상을 최소화하고 데이터 구조의 안정성을 향상시킬 수 있다.

정규화는 총 7단계가 존재한다. 3차 정규화까지 진행하면 정규화된 것으로 간주하기도한다.

## 6. 인덱스를 정의한다.

인덱스(Index) : 레코드를 빠르게 찾을 수 있도록 하는 자료 구조. 책의 마지막 장에 있는 인덱스의 역할과 비슷하다. 종류로는 Clustered, Non-Clustered, Composite 인덱스가 있다.

* Clustered Index : 튜플의 물리적 순서에 따라 인덱스가 생성된다. 기본키 기준으로 자동으로 생성되며 다른 필드를 가리키도록 변경할 수 있다.

* Non-Clustered Index : 테이블마다 249개의 인덱스까지 생성할 수 있다. 레코드를 삽입, 갱신, 삭제 시 인덱스가 반드시 업데이트 되어야 하므로 꼭 필요할 때만 인덱스를 생성한다.

* Composite Index : 두 개 이상의 속성으로 구성된 인덱스를 말한다. 인덱스로 구성된 속성들이 자주 변하지 않고 인덱스만으로 거의 모든 조건 검색이 가능할 때 사용한다.



reference: B. Syverson, J. Murach, _Murach's SQL Server 2016 For Developers_, 2nd ed.